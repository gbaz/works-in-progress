{-# LANGUAGE GADTs #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UndecidableInstances #-}

module Planar where
import Debug.Trace


-- context is generated by zero, extension (add one to the right), usage (move turnstile left), and closure (chop off right side of turnstile).

-- for each variable introduced, after the application (or introduction) of which term is it introduced. so a backedge, for each n, some m < n, with no crossing

{-
type Planar = [Int]

planars1 = 0 : (ma

-}


{- doesn't work, need more info.  Nats to tree. Don't just say can  take a var, but which  var. -}
-- tree gives vars that a term promises to consume
data C = Z | L C | R C | S C deriving (Read, Show) -- turn into tree of context splittings

data Planar (takes :: C) where
   PBindAppL  :: Planar (L a) -> Planar a -> Planar a -- need to use some on left, and some on right
   PBindAppR  :: Planar a -> Planar (R a) -> Planar a -- need to use some on left, and some on right
   PBindNest  :: Planar (S a) -> Planar a
   PVar :: Planar (S Z)
   PVarL :: Planar (L Z)
   PVarR :: Planar (R Z)
   Yawp :: C -> Planar a

class RC (a :: C) where
  rc :: f a -> C

instance RC Z where rc _ = Z
instance RC (S a) where rc x = S (rc x) -- reduce
instance RC (R a) where rc x = R (rc x)

instance RC (L a) where rc x = L (rc x)

--  rule out twovar case duplication and other symmetries

deriving instance Show (Planar a)

-- lambdas need to track what they consume, as do apps


-- int is vars allowed/required to intro, nat is vars allowed/required to consume
class GenPlanar (a::C) where
  genPlanarZero :: [Planar a]
  genPlanar :: Int ->  [Planar a]
  genPlanar 0 = genPlanarZero
  genPlanar n =  ss ++ as ++ rs where
  -- should be mix of intro and consume, not just intro?
   as = do
     left <- [0..n-1]
     _ <- trace (show left) $ return ()
     lbind <- genPlanar left
--     _ <- trace (show lbind) $ return ()
     rbind <- genPlanar (n -left)
--     _ <- trace (show rbind) $ return ()
     return $ PBindAppL lbind rbind
   rs = do
     left <- [0..n-1]
     lbind <-   genPlanar left
     rbind <-   genPlanar (n - left)
     return $ PBindAppR lbind rbind

   ss | n > 0 =  fmap PBindNest (genPlanar (n - 1))
      | otherwise = []

-- these overlaps suck, need a closed type family ugh

instance GenPlanar Z where genPlanarZero = []
instance GenPlanar (S Z) where genPlanarZero = [PVar]
instance GenPlanar (R Z) where genPlanarZero = [PVarR]
instance GenPlanar (L Z) where genPlanarZero = [PVarL]
instance {-# OVERLAPPABLE #-} RC a => GenPlanar a where genPlanarZero = let res = [Yawp (rc $ head res)] in res
{-
instance GenPlanar (S a) where genPlanarZero = []
instance GenPlanar (L a) where genPlanarZero = []
instance GenPlanar (R a) where genPlanarZero = []
-}
{-

class GenPlanarZero (a::C) where
  genPlanarZero :: [Planar a]

instance GenPlanarZero Z where genPlanarZero = []
instance GenPlanarZero (S Z) where genPlanarZero = [PVar]
instance GenPlanarZero (R Z) where genPlanarZero = [PVarR]
instance GenPlanarZero (L Z) where genPlanarZero = [PVarL]
instance GenPlanarZero (S a) where genPlanarZero = []
instance GenPlanarZero (L a) where genPlanarZero = []
instance GenPlanarZero (R a) where genPlanarZero = []

instance GenPlanarZero a => GenPlanar a where
  genPlanar 0 = genPlanarZero
  genPlanar n =  ss ++ as ++ rs where
  -- should be mix of intro and consume, not just intro?
   as = do
     left <- [0..n-1]
     _ <- trace (show left) $ return []
     lbind <- genPlanarZero ++ genPlanar left
     _ <- trace (show lbind) $ return []
     rbind <- genPlanarZero ++ genPlanar (n - 1 -left)
     _ <- trace (show rbind) $ return []
     return $ PBindAppL lbind rbind

   rs = do
     left <- [0..n-1]
     lbind <- genPlanarZero ++  genPlanar left
     rbind <- genPlanarZero ++ genPlanar (n - 1 -left)
     return $ PBindAppR lbind rbind

   ss | n > 0 =  fmap PBindNest (genPlanar (n - 1))
      | otherwise = []
-}
{-
instance  GenPlanar Z where
  genPlanar 0 = []
  genPlanar n = ss ++ as ++ rs where
  -- should be mix of intro and consume, not just intro?
   res = ss ++ as ++ rs
   as = do
     left <- [0..n-1]
     lbind <- genPlanar left
     rbind <- genPlanar (n - 1 -left)
     return $ PBindAppL lbind rbind

   rs = do
     left <- [0..n-1]
     lbind <- genPlanar left
     rbind <- genPlanar (n - 1 -left)
     return $ PBindAppR lbind rbind

   ss | n > 0 =  fmap PBindNest (genPlanar (n - 1))
      | otherwise = []


instance  GenPlanar (S Z) where
  genPlanar 0 = [PVar]
  genPlanar n = ss ++ as ++ rs where
   res = ss ++ as ++ rs
   as = do
     left <- [0..n-1]
     lbind <- genPlanar left
     rbind <- genPlanar (n - 1 -left)
     return $ PBindAppL lbind rbind

   rs = do
     left <- [0..n-1]
     lbind <- genPlanar left
     rbind <- genPlanar (n - 1 -left)
     return $ PBindAppR lbind rbind

   ss | n > 0 =  fmap PBindNest (genPlanar (n - 1))
      | otherwise = []


instance  GenPlanar (S a) where
  genPlanar 0 = []
  genPlanar n = ss ++ as ++ rs where
   as = do
     left <- [0..n-1]
     lbind <- genPlanar left
     rbind <- genPlanar (n - 1 -left)
     return $ PBindAppL lbind rbind

   rs = do
     left <- [0..n-1]
     lbind <- genPlanar left
     rbind <- genPlanar (n - 1 -left)
     return $ PBindAppR lbind rbind

   ss | n > 0 =  fmap PBindNest (genPlanar (n - 1))
      | otherwise = []

instance  GenPlanar (L Z) where
  genPlanar 0 = [PVarL]
  genPlanar n = ss ++ as ++ rs where
   as = do
     left <- [0..n-1]
     lbind <- genPlanar left
     rbind <- genPlanar (n - 1 -left)
     return $ PBindAppL lbind rbind

   rs = do
     left <- [0..n-1]
     lbind <- genPlanar left
     rbind <- genPlanar (n - 1 -left)
     return $ PBindAppR lbind rbind

   ss | n > 0 =  fmap PBindNest (genPlanar (n - 1))
      | otherwise = []

instance  GenPlanar (L a) where
  genPlanar 0 = []
  genPlanar n = ss ++ as ++ rs where
   as = do
     left <- [0..n-1]
     lbind <- genPlanar left
     rbind <- genPlanar (n - 1 -left)
     return $ PBindAppL lbind rbind

   rs = do
     left <- [0..n-1]
     lbind <- genPlanar left
     rbind <- genPlanar (n - 1 -left)
     return $ PBindAppR lbind rbind

   ss | n > 0 =  fmap PBindNest (genPlanar (n - 1))
      | otherwise = []

instance  GenPlanar (R Z) where
  genPlanar 0 = []
  genPlanar n = ss ++ as ++ rs where
   as = do
     left <- [0..n-1]
     lbind <- genPlanar left
     rbind <- genPlanar (n - 1 -left)
     return $ PBindAppL lbind rbind

   rs = do
     left <- [0..n-1]
     lbind <- genPlanar left
     rbind <- genPlanar (n - 1 -left)
     return $ PBindAppR lbind rbind

   ss | n > 0 =  fmap PBindNest (genPlanar (n - 1))
      | otherwise = []

instance  GenPlanar (R a) where
  genPlanar 0 = []
  genPlanar n = ss ++ as ++ rs where
   as = do
     left <- [0..n-1]
     lbind <- genPlanar left
     rbind <- genPlanar (n - 1 -left)
     return $ PBindAppL lbind rbind

   rs = do
     left <- [0..n]
     lbind <- genPlanar left
     rbind <- genPlanar (n - 1 -left)
     return $ PBindAppR lbind rbind

   ss | n > 0 =  fmap PBindNest (genPlanar (n - 1))
      | otherwise = []
-}
gpz :: Int -> [Planar Z]
gpz = genPlanar

gps :: Int -> [Planar (S Z)]
gps = genPlanar

gpss :: Int -> [Planar (S (S Z))]
gpss = genPlanar

lgpz :: Int -> Int
lgpz = length . gpz

sgpz = mapM_ putStrLn . map showPlanar . gpz

showPlanar :: Planar Z -> String
showPlanar x = snd $ go (['a'..'z'],['!','!','!']) x
  where
     go :: ([Char],[Char])-> Planar a -> (([Char],[Char]),String) -- two lists. name store + name used store
     go ((n:names),(v:vnames)) p =
         case p of
           PVar -> ((n:names,vnames),v:[])
           PBindAppL x y ->
              let (n1,x1) = go (names,(n:v:vnames)) x
              in  fmap (\s-> ('\\':n:".") ++ "("++x1++")("++s++")") (go n1 y)
           PBindAppR x y ->
              let (n1,x1) = go (names,(n:v:vnames)) x
              in  fmap (\s-> ('\\':n:".") ++ "("++s++")("++x1++")") (go n1 y)
           PBindNest x -> fmap (('\\':n:".") ++) $ go (names,n:v:vnames) x

--need only half the binds
-- need to have left/right because can only use a var in one. BUT can only use vars in right that don't cross left, ugh.