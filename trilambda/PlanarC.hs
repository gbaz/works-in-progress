{-# LANGUAGE GADTs #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE TupleSections #-}

module PlanarC where
import Debug.Trace


-- context is generated by zero, extension (add one to the right), usage (move turnstile left), and closure (chop off right side of turnstile).

data Nat = Z | S Nat deriving (Read, Show, Eq)


data C = C [Nat] [Nat] deriving (Read, Show, Eq)

-- variables used in scope, terms built in scope
empty = C [Z] [Z]

partitions (S Z) = [(S Z, Z)]
partitions (S x) = (S Z, x) : map (\(a,b) -> (S a, b)) (partitions x)

intro :: C -> [C]
intro (C (h:hs) ts) = map (\(h1,h2) -> C (h1 : h2 : hs) (Z : ts)) (partitions (S h))
intro (C h ts) = [C (S Z : h) (Z : ts)]

shift :: C -> [C]
shift (C (S h : hs) (t:ts)) = [C (h : hs) (S t : ts)]
shift _ = []

app :: C -> [C]
app (C h (S (S t) : ts)) = [C h (S t : ts)]
app _ = []

close :: C -> [C]
close (C (Z:hs) (S Z:t:ts)) = [C hs (S t : ts)]
close _ = []

data Op = CI | CA | CS | CC deriving (Read, Show, Eq, Ord)

genTerm :: Int -> [[Op]]
genTerm x = map snd $ go x (empty,[])
  where go n (c,os) = is ++ ss ++ as ++ cs
         where
          is | n == 0 = if c == C [Z] [S Z] then [(c,os)] else []
             | otherwise = go (n - 1) . (,CI:os) =<< intro c
          as = go n . (,CA:os) =<< app c
          ss = go n . (,CS:os) =<< shift c
          cs = go n . (,CC:os) =<< close c

data FOL = Bind String FOL | App FOL FOL | Var String deriving Show

--termToFOL :: [OP] -> FOL
termToFOL xs =  snd $ go ['a'..'z'] [] [] (reverse xs)
  where go ns cxt [t] [] = (([],[],[],[]),t)
        go (n:ns) cxt tms (CI:os) =
                  let ((ns', cxt', tms', os'),body) =  go ns (n:cxt) [] os
                  -- should be cxt == cxt'
                  in go ns' cxt' ((Bind (n:[]) body) : tms) os'
        go ns (v:cxt) tms (CS:os) = go ns cxt ((Var (v:[])):tms) os
        go ns (cxt) tms (CA:os) = case tms of
                                       (t1:t2:ts) -> go ns cxt ((App t1 t2) :ts) os
        go ns cxt (t:[]) (CC:os) = ((ns,cxt,[],os),t)

        go ns cxt tms os = error $ show (ns, cxt, tms, os)


showFOL (Bind s x) = "\\"++s++"."++showFOL x
showFOL (App x y) = "("++showFOL x ++ ")(" ++ showFOL y ++ ")"
showFOL (Var s) = s

-- term generation is right, printing algo is probably right but alpha namings can be nonintuitive
sft = mapM_ putStrLn . map showFOL . map termToFOL . genTerm

{-

WOOT !

*PlanarC> map length (map genTerm [1..])
[1,4,32,336,4096,54912,

-}