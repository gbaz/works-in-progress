{-# LANGUAGE GADTs #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE TupleSections #-}

module PlanarC where
import Debug.Trace


-- context is generated by zero, extension (add one to the right), usage (move turnstile left), and closure (chop off right side of turnstile).

data Nat = Z | S Nat deriving (Read, Show, Eq)

-- data Tree = L | B Tree Tree deriving (Read, Show, Eq)

data C = C Nat [Nat] deriving (Read, Show, Eq)

empty = C Z []

intro :: C -> C
intro (C h ts) = C (S h) (Z : ts)

shift :: C -> [C]
shift (C (S h) (t:ts)) = [C h (S t : ts)]
shift _ = []

-- no apply?
app :: C -> [C]
app (C h (S (S t) : ts)) = [C h (S t : ts)]
app _ = []

close :: C -> [C]
close (C h (S Z:t:ts)) =  [C h (S t : ts)]
close (C h (S Z:[])) =  [C h []]
-- close (C h (Z:ts)) =  Just (C h ts)
close _ = []

data Op = CI | CA | CS | CC deriving (Read, Show, Eq, Ord)

genTerm :: Int -> [(C,[Op])]
genTerm x = go x (empty,[])
  where go n (c,os) = is ++ ss ++ as ++ cs
         where
          is | n == 0 = if c == empty then [(c,os)] else []
             | otherwise = go (n - 1) (intro c, CI : os)
          as = go n . (,CA:os) =<< app c
          ss = go n . (,CS:os) =<< shift c
          cs = go n . (,CC:os) =<< close c

termToLam :: [Op] -> String
termToLam xs = go ['a'..'z'] [] (reverse xs)
  where go (n:ns) cxt (CI:os) = ('(':'\\':n:'.':[]) ++ go ns (n:cxt) os
        go ns (v:cxt) (CS:os) = '[':v : go ns cxt os
        go ns (cxt) (CA:os) = ']': go ns cxt os -- halp
        go ns cxt (CC:os) = ")" ++ go ns cxt os
        go ns cxt [] = []
        go ns cxt os = error $ show (ns, cxt, os)

sgt = mapM_ putStrLn . map termToLam . map snd . genTerm

data FOL = Bind String FOL | App FOL FOL | Var String

--termToFOL :: [OP] -> FOL
termToFOL xs = go ['a'..'z'] [] (reverse xs)
  where go (n:ns) cxt (CI:os) = fmap (Bind (n:[])) $ go ns (n:cxt) os
        go ns (v:cxt) (CS:os) = ((ns, cxt, os), Var (v:[]))
        go ns (cxt) (CA:os) = let ((n,c,o),x) = go ns cxt os
                                  ((n',c',o'),y) = go n c o
                              in ((n',c',o'),App x y)
{-
        go ns cxt (CC:os) = ")" ++ go ns cxt os
        go ns cxt [] = []
        go ns cxt os = error $ show (ns, cxt, os)
-}