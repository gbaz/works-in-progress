/-
Copyright (c) 2014 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Jeremy Avigad

The rational numbers as a field generated by the integers, defined as the usual quotient.
-/
import types.int algebra.field hit.set_quotient hit.trunc int_order
open eq sigma sigma.ops equiv is_equiv equiv.ops eq.ops int algebra set_quotient is_trunc trunc quotient

record prerat : Type :=
(num : ℤ) (denom : ℤ) (denom_pos : denom > 0)


namespace prerat

definition equiv (a b : prerat) : Type.{0} :=
  int.mul (prerat.num a) (prerat.denom b) =
  int.mul (prerat.num b) (prerat.denom a)

infix `≡` := equiv

theorem equiv.refl [refl] (a : prerat) : a ≡ a := rfl

theorem equiv.symm [symm] {a b : prerat} (H : a ≡ b) : b ≡ a := !inverse H

theorem num_eq_zero_of_equiv {a b : prerat} (H : a ≡ b) (na_zero : num a = 0) : num b = 0 :=
have num a * denom b = 0, from !zero_mul ▸ na_zero ▸ rfl,
have num b * denom a = 0, from H ▸ this,
show num b = 0, from sum_resolve_left (eq_zero_or_eq_zero_of_mul_eq_zero this) (ne_of_gt (denom_pos a))

theorem num_pos_of_equiv {a b : prerat} (H : a ≡ b) (na_pos : num a > 0) : num b > 0 :=
have num a * denom b > 0, from mul_pos na_pos (denom_pos b),
have num b * denom a > 0, from H ▸ this,
show num b > 0, from pos_of_mul_pos_right this (le_of_lt (denom_pos a))

theorem num_neg_of_equiv {a b : prerat} (H : a ≡ b) (na_neg : num a < 0) : num b < 0 :=
have num a * denom b < 0, from mul_neg_of_neg_of_pos na_neg (denom_pos b),
have -(-num b * denom a) < 0, from !neg_mul_eq_neg_mul⁻¹ ▸ !neg_neg⁻¹ ▸ H ▸ this,
have -num b > 0, from pos_of_mul_pos_right (pos_of_neg_neg this) (le_of_lt (denom_pos a)),
neg_of_neg_pos this

theorem equiv_of_num_eq_zero {a b : prerat} (H1 : num a = of_nat 0) (H2 : num b = of_nat 0) : a ≡ b :=
by rewrite [↑equiv, H1, H2, *zero_mul]

theorem equiv.trans [trans] {a b c : prerat} (H1 : a ≡ b) (H2 : b ≡ c) : a ≡ c :=
decidable.by_cases
  (suppose num b = 0,
    have num a = 0, from num_eq_zero_of_equiv (equiv.symm H1) `num b = 0`,
    have num c = 0, from num_eq_zero_of_equiv H2 `num b = 0`,
    equiv_of_num_eq_zero `num a = 0` `num c = 0`)
  (suppose num b ≠ 0,
    have H3 : num b * denom b ≠ 0, from mul_ne_zero this (ne_of_gt (denom_pos b)),
    have H4 : (num b * denom b) * (num a * denom c) = (num b * denom b) * (num c * denom a),
      from calc
        (num b * denom b) * (num a * denom c) = (num a * denom b) * (num b * denom c) :
                    by rewrite [*mul.assoc, *mul.left_comm (num a), *mul.left_comm (num b)]
          ... = (num b * denom a) * (num b * denom c)                                 : {H1}
          ... = (num b * denom a) * (num c * denom b)                                 : {H2}
          ... = (num b * denom b) * (num c * denom a)                                 :
                    by rewrite [*mul.assoc, *mul.left_comm (denom a),
                                   *mul.left_comm (denom b), mul.comm (denom a)],
    eq_of_mul_eq_mul_left H3 H4)


/- field operations -/

definition of_int (i : int) : prerat := prerat.mk i (of_nat (nat.succ nat.zero)) !of_nat_succ_pos

definition zero : prerat := of_int (of_nat nat.zero)

definition one : prerat := of_int (of_nat (nat.succ nat.zero))

private theorem mul_denom_pos (a b : prerat) : denom a * denom b > 0 :=
mul_pos (denom_pos a) (denom_pos b)

definition add (a b : prerat) : prerat :=
prerat.mk (num a * denom b + num b * denom a) (denom a * denom b) (mul_denom_pos a b)

definition mul (a b : prerat) : prerat :=
prerat.mk (num a * num b) (denom a * denom b) (mul_denom_pos a b)

definition neg (a : prerat) : prerat :=
prerat.mk (- num a) (denom a) (denom_pos a)

definition smul (a : ℤ) (b : prerat) (H : a > 0) : prerat :=
prerat.mk (a * num b) (a * denom b) (mul_pos H (denom_pos b))

--set_option pp.all true

theorem of_int_add (a b : ℤ) : of_int (int.add (#int a) b) ≡ add (of_int a) (of_int b) :=
by esimp [equiv, num, denom, one, add, of_int]; rewrite [+int.mul_one]

theorem of_int_mul (a b : ℤ) : of_int (#int a * b) ≡ mul (of_int a) (of_int b) :=
!equiv.refl

theorem of_int_neg (a : ℤ) : of_int (#int -a) ≡ neg (of_int a) :=
!equiv.refl

theorem of_int.inj {a b : ℤ} : of_int a ≡ of_int b → a = b :=
by rewrite [↑of_int, ↑equiv, +mul_one]; intros; assumption

definition inv : prerat → prerat
| inv (prerat.mk nat.zero d dp)     := zero
| inv (prerat.mk (nat.succ n) d dp) := prerat.mk d (nat.succ n) !of_nat_succ_pos
| inv (prerat.mk (neg_succ_of_nat n) d dp)       := prerat.mk (-d) (nat.succ n) !of_nat_succ_pos

theorem equiv_zero_of_num_eq_zero {a : prerat} (H : num a = 0) : a ≡ zero :=
by rewrite [↑equiv, H, ↑zero, ↑num, ↑of_int, +zero_mul]

theorem num_eq_zero_of_equiv_zero {a : prerat} : a ≡ zero → num a = 0 :=
by rewrite [↑equiv, ↑zero, ↑of_int, mul_one, zero_mul]; intro H; exact H

theorem inv_zero {d : int} (dp : d > 0) : inv (mk nat.zero d dp) = zero :=
begin rewrite [↑inv, ▸*] end

theorem inv_zero' : inv zero = zero := inv_zero (of_nat_succ_pos nat.zero)

theorem inv_of_pos {n d : int} (np : n > 0) (dp : d > 0) : inv (mk n d dp) ≡ mk d n np :=
obtain (n' : nat) (Hn' : n = of_nat n'), from exists_eq_of_nat (le_of_lt np),
have (#nat n' > nat.zero), from lt_of_of_nat_lt_of_nat (Hn' ▸ np),
obtain (k : nat) (Hk : n' = nat.succ k), from nat.exists_eq_succ_of_lt this,
have d * n = d * nat.succ k, by rewrite [Hn', Hk],
Hn'⁻¹ ▸ (Hk⁻¹ ▸ this)

theorem inv_neg {n d : int} (np : n > 0) (dp : d > 0) : inv (mk (-n) d dp) ≡ mk (-d) n np :=
obtain (n' : nat) (Hn' : n = of_nat n'), from exists_eq_of_nat (le_of_lt np),
have (#nat n' > nat.zero), from lt_of_of_nat_lt_of_nat (Hn' ▸ np),
obtain (k : nat) (Hk : n' = nat.succ k), from nat.exists_eq_succ_of_lt this,
have -d * n = -d * nat.succ k, by rewrite [Hn', Hk],
have H3 : inv (mk (neg_succ_of_nat k) d dp) ≡ mk (-d) n np, from this,
have H4 : neg_succ_of_nat k = -n, from calc
  neg_succ_of_nat k = -(nat.succ k) : rfl
      ... = -n            : by rewrite [Hk⁻¹, Hn'],
H4 ▸ H3

theorem inv_of_neg {n d : int} (nn : n < 0) (dp : d > 0) :
  inv (mk n d dp) ≡ mk (-d) (-n) (neg_pos_of_neg nn) :=
have inv (mk (-(-n)) d dp) ≡ mk (-d) (-n) (neg_pos_of_neg nn),
  from inv_neg (neg_pos_of_neg nn) dp,
!neg_neg ▸ this

/- operations respect equiv -/

theorem add_equiv_add {a1 b1 a2 b2 : prerat} (eqv1 : a1 ≡ a2) (eqv2 : b1 ≡ b2) :
  add a1 b1 ≡ add a2 b2 :=
calc
  (num a1 * denom b1 + num b1 * denom a1) * (denom a2 * denom b2)
      = num a1 * denom a2 * denom b1 * denom b2 + num b1 * denom b2 * denom a1 * denom a2 :
          by rewrite [mul.right_distrib, *mul.assoc, mul.left_comm (denom b1),
                      mul.comm (denom b2), *mul.assoc]
  ... = num a2 * denom a1 * denom b1 * denom b2 + num b2 * denom b1 * denom a1 * denom a2 :
          by rewrite [↑equiv at *, eqv1, eqv2]
  ... = (num a2 * denom b2 + num b2 * denom a2) * (denom a1 * denom b1) :
          by rewrite [mul.right_distrib, *mul.assoc, *mul.left_comm (denom b2),
                      *mul.comm (denom b1), *mul.assoc, mul.left_comm (denom a2)]

theorem mul_equiv_mul {a1 b1 a2 b2 : prerat} (eqv1 : a1 ≡ a2) (eqv2 : b1 ≡ b2) :
  mul a1 b1 ≡ mul a2 b2 :=
calc
  (num a1 * num b1) * (denom a2 * denom b2)
      = (num a1 * denom a2) * (num b1 * denom b2) : by rewrite [*mul.assoc, mul.left_comm (num b1)]
  ... = (num a2 * denom a1) * (num b2 * denom b1) : by rewrite [↑equiv at *, eqv1, eqv2]
  ... = (num a2 * num b2) * (denom a1 * denom b1) : by rewrite [*mul.assoc, mul.left_comm (num b2)]

theorem neg_equiv_neg {a b : prerat} (eqv : a ≡ b) : neg a ≡ neg b :=
calc
  -num a * denom b = -(num a * denom b) : int.neg_mul_eq_neg_mul
               ... = -(num b * denom a) : {eqv}
               ... = -num b * denom a   : int.neg_mul_eq_neg_mul

theorem inv_equiv_inv : Π{a b : prerat}, a ≡ b → inv a ≡ inv b
| (mk an ad adp) (mk bn bd bdp) :=
  assume H,
  lt.by_cases
    (assume an_neg : an < 0,
      have bn_neg : bn < 0, from num_neg_of_equiv H an_neg,
      calc
        inv (mk an ad adp) ≡ mk (-ad) (-an) (neg_pos_of_neg an_neg) : inv_of_neg an_neg adp
                       ... ≡ mk (-bd) (-bn) (neg_pos_of_neg bn_neg) :
                             by rewrite [↑equiv at *, ▸*, *neg_mul_neg, mul.comm ad, mul.comm bd, H]
                       ... ≡ inv (mk bn bd bdp)                     : (inv_of_neg bn_neg bdp)⁻¹)
    (assume an_zero : an = 0,
      have bn_zero : bn = 0, from num_eq_zero_of_equiv H an_zero,
      eq.subst (calc
        inv (mk an ad adp) = inv (mk 0 ad adp)  : {an_zero}
                       ... = zero               : inv_zero
                       ... = inv (mk 0 bd bdp)  : inv_zero
                       ... = inv (mk bn bd bdp) : bn_zero) !equiv.refl)
    (assume an_pos : an > 0,
      have bn_pos : bn > 0, from num_pos_of_equiv H an_pos,
      calc
        inv (mk an ad adp) ≡ mk ad an an_pos    : inv_of_pos an_pos adp
                       ... ≡ mk bd bn bn_pos    :
                                by rewrite [↑equiv at *, ▸*, mul.comm ad, mul.comm bd, H]
                       ... ≡ inv (mk bn bd bdp) : (inv_of_pos bn_pos bdp)⁻¹)

theorem smul_equiv {a : ℤ} {b : prerat} (H : a > 0) : smul a b H ≡ b :=
by esimp[equiv, smul]; rewrite[mul.assoc, mul.left_comm]

/- properties -/

theorem add.comm (a b : prerat) : add a b ≡ add b a :=
by rewrite [↑add, ↑equiv, ▸*, add.comm, mul.comm (denom a)]

theorem add.assoc (a b c : prerat) : add (add a b) c ≡ add a (add b c) :=
by rewrite [↑add, ↑equiv, ▸*, *(mul.comm (num c)), *(λy, mul.comm y (denom a)), *mul.left_distrib,
            *mul.right_distrib, *mul.assoc, *add.assoc]

theorem add_zero (a : prerat) : add a zero ≡ a :=
by rewrite [↑add, ↑equiv, ↑zero, ↑of_int, ▸*, *mul_one, zero_mul, add_zero]

theorem add.left_inv (a : prerat) : add (neg a) a ≡ zero :=
by rewrite [↑add, ↑equiv, ↑neg, ↑zero, ↑of_int, ▸*, -neg_mul_eq_neg_mul, add.left_inv, *zero_mul]

theorem mul.comm (a b : prerat) : mul a b ≡ mul b a :=
by rewrite [↑mul, ↑equiv, mul.comm (num a), mul.comm (denom a)]

theorem mul.assoc (a b c : prerat) : mul (mul a b) c ≡ mul a (mul b c) :=
by rewrite [↑mul, ↑equiv, *mul.assoc]

theorem mul_one (a : prerat) : mul a one ≡ a :=
by rewrite [↑mul, ↑one, ↑of_int, ↑equiv, ▸*, *mul_one]

theorem mul.left_distrib (a b c : prerat) : mul a (add b c) ≡ add (mul a b) (mul a c) :=
have H : smul (denom a) (mul a (add b c)) (denom_pos a) =
   add (mul a b) (mul a c), from begin
  rewrite[↑smul, ↑mul, ↑add],
  congruence,
  rewrite[*mul.left_distrib, *mul.right_distrib, -*int.mul.assoc],
  have T : Π {x y z w : ℤ}, x*y*z*w=y*z*x*w, from
    λx y z w, (!int.mul.assoc ⬝ !int.mul.comm) ▸ rfl,
  exact !congr_arg2 T T,
  exact !mul.left_comm ▸ !int.mul.assoc⁻¹
end,
equiv.symm (H ▸ smul_equiv (denom_pos a))

theorem mul_inv_cancel : Π{a : prerat}, ¬ a ≡ zero → mul a (inv a) ≡ one
| (mk an ad adp) :=
  assume H,
  let a := mk an ad adp in
  lt.by_cases
    (assume an_neg : an < 0,
      let ia := mk (-ad) (-an) (neg_pos_of_neg an_neg) in
      calc
        mul a (inv a) ≡ mul a ia : mul_equiv_mul !equiv.refl (inv_of_neg an_neg adp)
                  ... ≡ one      : begin
                                     esimp [equiv, num, denom, one, mul, of_int],
                                     rewrite [*int.mul_one, *int.one_mul, int.mul.comm,
                                              neg_mul_comm]
                                   end)
    (assume an_zero : an = 0, absurd (equiv_zero_of_num_eq_zero an_zero) H)
    (assume an_pos : an > 0,
      let ia := mk ad an an_pos in
      calc
        mul a (inv a) ≡ mul a ia : mul_equiv_mul !equiv.refl (inv_of_pos an_pos adp)
                  ... ≡ one      : begin
                                     esimp [equiv, num, denom, one, mul, of_int],
                                     rewrite [*int.mul_one, *int.one_mul, int.mul.comm]
                                   end)

theorem zero_not_equiv_one : ¬ zero ≡ one :=
begin
  esimp [equiv, zero, one, of_int],
  rewrite [zero_mul, int.mul_one],
  exact zero_ne_one
end

theorem mul_denom_equiv (a : prerat) : mul a (of_int (denom a)) ≡ of_int (num a) :=
by esimp [mul, of_int, equiv]; rewrite [*int.mul_one]

/- Reducing a fraction to lowest terms. Needed to choose a canonical representative of rat, and
   define numerator and denominator. -/
/- TODO must port int.div first

definition reduce : prerat → prerat
| (mk an ad adpos) :=
    have pos : ad div gcd an ad > 0, from div_pos_of_pos_of_dvd adpos !gcd_nonneg !gcd_dvd_right,
    if an = 0 then prerat.zero
              else mk (an div gcd an ad) (ad div gcd an ad) pos
-/

--TODO prove int equality is an hset?

protected theorem eq {a b : prerat} (Hn : num a = num b) (Hd : denom a = denom b) : a = b :=
begin
  cases a with [an, ad, adpos],
  cases b with [bn, bd, bdpos],
  generalize adpos, generalize bdpos,
  esimp at *,
  rewrite [Hn, Hd],
  intros,
  apply rfl
end
/-
theorem reduce_equiv : Π a : prerat, reduce a ≡ a
| (mk an ad adpos) :=
    decidable.by_cases
      (assume anz : an = 0,
        by krewrite [↑reduce, if_pos anz, ↑equiv, anz, *zero_mul])
      (assume annz : an ≠ 0,
        by rewrite [↑reduce, if_neg annz, ↑equiv, int.mul.comm, -!mul_div_assoc !gcd_dvd_left,
                       -!mul_div_assoc !gcd_dvd_right, int.mul.comm])

theorem reduce_eq_reduce : Π{a b : prerat}, a ≡ b → reduce a = reduce b
| (mk an ad adpos) (mk bn bd bdpos) :=
  assume H : an * bd = bn * ad,
  decidable.by_cases
    (assume anz : an = 0,
      have H' : bn * ad = 0, by rewrite [-H, anz, zero_mul],
      assert bnz : bn = 0,
        from sum_resolve_left (eq_zero_or_eq_zero_of_mul_eq_zero H') (ne_of_gt adpos),
      by rewrite [↑reduce, if_pos anz, if_pos bnz])
    (assume annz : an ≠ 0,
      assert bnnz : bn ≠ 0, from
        assume bnz,
        have H' : an * bd = 0, by rewrite [H, bnz, zero_mul],
        have anz : an = 0,
          from sum_resolve_left (eq_zero_or_eq_zero_of_mul_eq_zero H') (ne_of_gt bdpos),
        show empty, from annz anz,
      begin
        rewrite [↑reduce, if_neg annz, if_neg bnnz],
        apply prerat.eq,
          {apply div_gcd_eq_div_gcd H adpos bdpos},
          {esimp, rewrite [gcd.comm, gcd.comm bn],
            apply div_gcd_eq_div_gcd_of_nonneg,
              rewrite [int.mul.comm, -H, int.mul.comm],
              apply annz,
              apply bnnz,
              apply le_of_lt adpos,
              apply le_of_lt bdpos},
      end)
-/
end prerat

/-
  the rationals
-/

inductive prat_rel : prerat → prerat → Type :=
 | Rmk : Π (a b : prerat), prerat.equiv a b → prat_rel a b

definition prat_rel.elim {a b : prerat} (pr : prat_rel a b) : prerat.equiv a b := sorry

definition rat_rel (a : prerat) (b : prerat) : hprop := trunctype.mk (trunc -1 (prat_rel a b)) _

definition rat : Type.{0} := set_quotient rat_rel
notation `ℚ` := rat

namespace rat

/- operations -/

definition lift0 (p : prerat) : ℚ := set_quotient.class_of rat_rel p
definition of_int [coercion] (i : ℤ) : ℚ := lift0 (prerat.of_int i)
definition of_nat [coercion] (n : nat) : ℚ := of_int n
definition of_num [coercion] [reducible] (n : num) : ℚ := of_int (int.of_num n)

definition lift1 {A : Type} [hs : is_hset A] (f : prerat → A) (coh : Π (p q : prerat), rat_rel p q -> f p = f q) (r : rat) : A :=
set_quotient.elim_on rat_rel r f coh

definition add : ℚ → ℚ → ℚ := sorry
/-
quot.lift₂
  (λ a b : prerat, ⟦prerat.add a b⟧)
  (take a1 a2 b1 b2, assume H1 H2, quot.sound (prerat.add_equiv_add H1 H2))

definition mul : ℚ → ℚ → ℚ :=
quot.lift₂
  (λ a b : prerat, ⟦prerat.mul a b⟧)
  (take a1 a2 b1 b2, assume H1 H2, quot.sound (prerat.mul_equiv_mul H1 H2))
-/
--TODO prove is_hset Q, is_prop prerat_equiv

lemma equiv_to_eq {a b : prerat} (e : prerat.equiv a b) : lift0 a = lift0 b := sorry

definition neg : ℚ → ℚ := @lift1 _ sorry (λx, lift0 (prerat.neg x))
(λ (p q : prerat) (H : rat_rel p q), equiv_to_eq (prerat.neg_equiv_neg (@trunc.elim_on -1 _ _ H sorry prat_rel.elim)))

definition inv : ℚ → ℚ :=
quot.lift
  (λ a : prerat, ⟦prerat.inv a⟧)
  (take a1 a2, assume H, quot.sound (prerat.inv_equiv_inv H))

definition reduce : ℚ → prerat :=
quot.lift
  (λ a : prerat, prerat.reduce a)
  @prerat.reduce_eq_reduce

definition num (a : ℚ) : ℤ := prerat.num (reduce a)
definition denom (a : ℚ) : ℤ := prerat.denom (reduce a)

theorem denom_pos (a : ℚ): denom a > 0 :=
prerat.denom_pos (reduce a)

protected definition prio := num.pred int.prio

infix [priority rat.prio] +    := rat.add
infix [priority rat.prio] *    := rat.mul
prefix [priority rat.prio] -   := rat.neg

definition sub [reducible] (a b : rat) : rat := a + (-b)

postfix [priority rat.prio] ⁻¹ := rat.inv
infix [priority rat.prio] -    := rat.sub

/- properties -/

theorem of_int_add (a b : ℤ) : of_int (#int a + b) = of_int a + of_int b :=
quot.sound (prerat.of_int_add a b)

theorem of_int_mul (a b : ℤ) : of_int (#int a * b) = of_int a * of_int b :=
quot.sound (prerat.of_int_mul a b)

theorem of_int_neg (a : ℤ) : of_int (#int -a) = -(of_int a) :=
quot.sound (prerat.of_int_neg a)

theorem of_int_sub (a b : ℤ) : of_int (#int a - b) = of_int a - of_int b :=
calc
  of_int (#int a - b) = of_int a + of_int (#int -b) : of_int_add
                  ... = of_int a - of_int b         : {of_int_neg b}

theorem of_int.inj {a b : ℤ} (H : of_int a = of_int b) : a = b :=
prerat.of_int.inj (quot.exact H)

theorem of_nat_eq (a : ℕ) : of_nat a = of_int (int.of_nat a) := rfl

theorem of_nat_add (a b : ℕ) : of_nat (#nat a + b) = of_nat a + of_nat b :=
by rewrite [*of_nat_eq, int.of_nat_add, rat.of_int_add]

theorem of_nat_mul (a b : ℕ) : of_nat (#nat a * b) = of_nat a * of_nat b :=
by rewrite [*of_nat_eq, int.of_nat_mul, rat.of_int_mul]

theorem of_nat_sub {a b : ℕ} (H : #nat a ≥ b) : of_nat (#nat a - b) = of_nat a - of_nat b :=
by rewrite [*of_nat_eq, int.of_nat_sub H, rat.of_int_sub]

theorem add.comm (a b : ℚ) : a + b = b + a :=
quot.induction_on₂ a b (take u v, quot.sound !prerat.add.comm)

theorem add.assoc (a b c : ℚ) : a + b + c = a + (b + c) :=
quot.induction_on₃ a b c (take u v w, quot.sound !prerat.add.assoc)

theorem add_zero (a : ℚ) : a + 0 = a :=
quot.rec_on a (take u, quot.sound !prerat.add_zero)

theorem zero_add (a : ℚ) : 0 + a = a := !add.comm ▸ !add_zero

theorem add.left_inv (a : ℚ) : -a + a = 0 :=
quot.rec_on a (take u, quot.sound !prerat.add.left_inv)

theorem mul.comm (a b : ℚ) : a * b = b * a :=
quot.induction_on₂ a b (take u v, quot.sound !prerat.mul.comm)

theorem mul.assoc (a b c : ℚ) : a * b * c = a * (b * c) :=
quot.induction_on₃ a b c (take u v w, quot.sound !prerat.mul.assoc)

theorem mul_one (a : ℚ) : a * 1 = a :=
quot.rec_on a (take u, quot.sound !prerat.mul_one)

theorem one_mul (a : ℚ) : 1 * a = a := !mul.comm ▸ !mul_one

theorem mul.left_distrib (a b c : ℚ) : a * (b + c) = a * b + a * c :=
quot.induction_on₃ a b c (take u v w, quot.sound !prerat.mul.left_distrib)

theorem mul.right_distrib (a b c : ℚ) : (a + b) * c = a * c + b * c :=
by rewrite [mul.comm, mul.left_distrib, *mul.comm c]

theorem mul_inv_cancel {a : ℚ} : a ≠ 0 → a * a⁻¹ = 1 :=
quot.rec_on a
  (take u,
    assume H,
    quot.sound (!prerat.mul_inv_cancel (assume H1, H (quot.sound H1))))

theorem inv_mul_cancel {a : ℚ} (H : a ≠ 0) : a⁻¹ * a = 1 :=
!mul.comm ▸ mul_inv_cancel H

theorem zero_ne_one : (0 : ℚ) ≠ 1 :=
assume H, prerat.zero_not_equiv_one (quot.exact H)

definition has_decidable_eq [instance] : decidable_eq ℚ :=
take a b, quot.rec_on_subsingleton₂ a b
  (take u v,
     if H : prerat.num u * prerat.denom v = prerat.num v * prerat.denom u
       then decidable.inl (quot.sound H)
       else decidable.inr (assume H1, H (quot.exact H1)))

theorem inv_zero : inv 0 = 0 :=
quot.sound (prerat.inv_zero' ▸ !prerat.equiv.refl)

theorem quot_reduce (a : ℚ) : ⟦reduce a⟧ = a :=
quot.rec_on a (take u, quot.sound !prerat.reduce_equiv)

theorem mul_denom (a : ℚ) : a * denom a = num a :=
have H : ⟦reduce a⟧ * of_int (denom a) = of_int (num a), from quot.sound (!prerat.mul_denom_equiv),
quot_reduce a ▸ H

section migrate_algebra
  open [classes] algebra

  protected definition discrete_field [reducible] : algebra.discrete_field rat :=
  ⦃algebra.discrete_field,
    add              := add,
    add_assoc        := add.assoc,
    zero             := 0,
    zero_add         := zero_add,
    add_zero         := add_zero,
    neg              := neg,
    add_left_inv     := add.left_inv,
    add_comm         := add.comm,
    mul              := mul,
    mul_assoc        := mul.assoc,
    one              := (of_num 1),
    one_mul          := one_mul,
    mul_one          := mul_one,
    left_distrib     := mul.left_distrib,
    right_distrib    := mul.right_distrib,
    mul_comm         := mul.comm,
    mul_inv_cancel   := @mul_inv_cancel,
    inv_mul_cancel   := @inv_mul_cancel,
    zero_ne_one      := zero_ne_one,
    inv_zero         := inv_zero,
    has_decidable_eq := has_decidable_eq⦄

  local attribute rat.discrete_field [instance]

  definition divide (a b : rat) := algebra.divide a b
  infix [priority rat.prio] `/` := divide

  definition dvd (a b : rat) := algebra.dvd a b

  definition pow (a : ℚ) (n : ℕ) : ℚ := algebra.pow a n
  infix [priority rat.prio] ^ := pow

  migrate from algebra with rat
    replacing sub → rat.sub, divide → divide, dvd → dvd, pow → pow

end migrate_algebra

theorem eq_num_div_denom (a : ℚ) : a = num a / denom a :=
have H : of_int (denom a) ≠ 0, from assume H', ne_of_gt (denom_pos a) (of_int.inj H'),
iff.mp' (eq_div_iff_mul_eq H) (mul_denom a)

theorem of_nat_div {a b : ℤ} (H : b ∣ a) : of_int (a div b) = of_int a / of_int b :=
decidable.by_cases
  (assume bz : b = 0,
    by rewrite [bz, div_zero, int.div_zero])
  (assume bnz : b ≠ 0,
    have bnz' : of_int b ≠ 0, from assume oibz, bnz (of_int.inj oibz),
    have H' : of_int (a div b) * of_int b = of_int a, from
      int.dvd.elim H
        (take c, assume Hc : a = b * c,
          by rewrite [Hc, !int.mul_div_cancel_left bnz, mul.comm]),
    iff.mp' (eq_div_iff_mul_eq bnz') H')

end rat
