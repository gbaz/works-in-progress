#lang racket
(require racket/match)

; value formers
(struct lam-pi (var vt body) #:transparent)
(struct app (fun arg) #:transparent)
; primitives
(struct closure (typ body) #:transparent)
(struct trustme (typ body) #:transparent)

; type formers
(struct type-fun (dom codom) #:transparent)
; one basic type
(define type-unit 'type-unit)
; dependency
(struct type-pi (var dom codom) #:transparent)
(define type-type 'type) ;; inconsistent!

; contexts
(define (find-cxt nm cxt)
  (match (assoc nm cxt) [(cons a b) b] [_ #f]))

(define (fresh-var nm cxt)
  (if (assoc nm cxt) (fresh-var (string->symbol (string-append (symbol->string nm) "'")) cxt) nm))

(define-syntax-rule (extend-cxt var vt cxt (newvar newcxt) body)
  (let* ([newvar (fresh-var var cxt)]
         [newcxt (cons (cons newvar vt) cxt)])
    body))
                                  
(define/match (reduce cxt body) ; reduction is to whnf, call-by-name
  [(_ (app (lam-pi var vt  b) arg))
   (if (hasType? cxt arg vt) (reduce cxt (b arg)) ; the type check is optional. omitting gives nuprl semantics
       (raise-arguments-error 'bad-type "bad type"
                              "cxt" cxt "arg" arg "vt" vt "app" (lam-pi var vt b)))]
  [(_ (app (closure ty b) arg))
   (closure (app-type cxt (red-eval cxt ty) arg) (lambda (cxt) (app (b cxt) arg)))] ; applying closures produces closures
  [(_ (app fun arg)) (if (or (not fun) (symbol? fun))
                         (raise-arguments-error 'stuck "reduction stuck"
                                                "fun" fun "arg" arg)
                         (reduce cxt (app (reduce cxt fun) arg)))]
  [(_ _) body])

(define (red-eval cxt x)
  (match (reduce cxt x)
    [(closure typ b) (red-eval cxt (b cxt))]
    [(app (closure typ b) arg) (red-eval cxt (app (b cxt) arg))]
    [v v]))

(define/match (app-type cxt fun arg)
  [(_ (type-fun a b) _)
   (if (hasType? cxt arg a) b
       (raise-arguments-error 'bad-type "bad type applying in closure" "cxt" cxt "fun" fun "arg" arg))]
  [(_ (type-pi a at b) _)
   (if (hasType? cxt arg a) (b arg)
       (raise-arguments-error 'bad-type "bad pi type applying in closure" "cxt" cxt "fun" fun "arg" arg))]
  [(_ _ _) (raise-arguments-error 'bad-type "can't apply non-function type in closure" "cxt" cxt "fun" fun "arg" arg)])

(define (type? cxt t) 
  (match (red-eval cxt t)
    [(type-fun a b) (and (type? cxt a) (type? cxt b))]
    [(? symbol? vname) #:when (type? cxt (find-cxt vname cxt)) #t]
    ['type-unit #t]
    [(type-pi var a b)
     (and (type? cxt a) (extend-cxt var a cxt (newvar newcxt) (type? newcxt (b newvar))))]
    ['type #t]
    [t1 (type?-additional cxt t1)]
    ))

(define (hasType? cxt x1 t1)
  (match* ((reduce cxt x1) (red-eval cxt t1))
    [((closure typ b) t) (eqType? cxt typ t)]
    [((trustme typ b) t) (eqType? cxt typ t)]
    [((? symbol? x) t) #:when (eqType? cxt t (find-cxt x cxt)) #t]
    [((lam-pi vn vt body) (type-fun a b))
     (and (eqType? cxt vt a)
          (extend-cxt vn vt cxt (newvar newcxt) (hasType? newcxt (body newvar) b)))]
    [(x 'type-unit) (null? x)]
    [((lam-pi vn vt body) (type-pi _ a b))
     (and (eqType? cxt vt a)
          (extend-cxt vn vt cxt (newvar newcxt) 
                      (hasType? newcxt (body newvar) (reduce newcxt (b newvar)))))]
    [(x 'type) (type? cxt x)]
    [(x t) (hasType?-additional cxt x t)]))

(define (eqType? cxt t1 t2)
  (match* ((red-eval cxt t1) (red-eval cxt t2))
    [((type-fun a b) (type-fun a1 b1))
     (and (eqType? cxt a a1) (eqType? cxt b b1))]
    [((type-pi v a b) (type-pi v1 a1 b1))
     (and (eqType? cxt a a1)
          (extend-cxt v a cxt (newvar newcxt) 
                      (eqType? newcxt (b newvar) (b1 newvar))))]
    [((? symbol? vname) (? symbol? vname1)) (eq? vname vname1)]
    [(a b) (and a b (or (eqType?-additional cxt a b)
                        (begin (printf "not equal\n ~a\n ~a\n cxt: ~a\n" a b cxt) #f)))]))

(define (eqVal? cxt typ v1 v2)
  (match* ((red-eval cxt typ) (red-eval cxt v1) (red-eval cxt v2))
    [((type-fun a b) (lam-pi x xt body) (lam-pi y yt body2))
     (and (eqType? cxt a xt) (eqType? cxt a yt)
          (extend-cxt x xt cxt (newv newcxt)
                      (eqVal? newcxt b (body newv) (body2 newv))))]
    [((type-pi v a b) (lam-pi x xt body) (lam-pi y yt body2))
     (and (eqType? cxt a xt) (eqType? cxt a yt)
          (extend-cxt x xt cxt (newv newcxt)
                      (eqVal? newcxt (b newv) (body newv) (body2 newv))))]
    [('type-unit '() '()) #t]
    [('type-type a b) (eqType? cxt a b)]
    [(_ (? symbol? x) (? symbol? y)) #:when (eq? x y) #t]
    [(_ (trustme t v) (trustme t1 v1)) (and (eqType? cxt t t1) (equal? v v1))] ;if all else fails use primitive equality
    [(rtyp x y) (eqVal?-additional cxt rtyp x y)]))

(define type-judgments '())
(define (type?-additional cxt t)
  (for/or ([p type-judgments]) (p cxt t)))

(define hasType-judgments '())
(define (hasType?-additional cxt x t)
  (for/or ([p hasType-judgments]) (p cxt x t)))

(define eqType-judgments '())
(define (eqType?-additional cxt t1 t2)
  (for/or ([p eqType-judgments]) (p cxt t1 t2)))

(define eqVal-judgments '())
(define (eqVal?-additional cxt typ v1 v2)
  (for/or ([p eqVal-judgments]) (p cxt typ v1 v2)))

(define apps
  (lambda (fun . args)
    (foldl (lambda (arg acc) (app acc arg)) fun args)))

(define-syntax-rule (lam   (x t) body) (lam-pi  (quote x) t (lambda (x) body)))
(define-syntax-rule (pi    (x t) body) (lam-pi  (quote x) t (lambda (x) body)))
(define-syntax-rule (pi-ty (x t) body) (type-pi (quote x) t (lambda (x) body)))
(define-syntax-rule (close    t  body) (closure t body))

(displayln "id-unit: is type, has type")
(define id-unit (lam (x type-unit) x))
; (define id-unit (lam 'x type-unit (lambda (x) x)))
(define id-unit-type (type-fun type-unit type-unit))
(type?    '() id-unit-type)
(hasType? '() id-unit  id-unit-type)

(displayln "id-forall: is type, has type")
(define id-forall (pi (t type-type) (lam (x t) x)))
; (define id-forall (lam 'x type-type (lambda (x) (lam 'y x (lambda (y) y)))))
(define id-forall-type (pi-ty (tau type-type) (type-fun tau tau)))
; (define id-forall-type (type-pi 'tau type-type (lambda (tau) (type-fun tau tau))))
(type?    '() id-forall-type)
(hasType? '() id-forall id-forall-type)

(displayln "id-forall: application typechecks")
(hasType? '() (app id-forall type-unit) id-unit-type)
(hasType? '() (apps id-forall type-unit '()) type-unit)

(displayln "k-comb: is type, has type")
(define k-comb 
  (pi (a type-type) (lam (x a) (pi (b type-type) (lam (y b) x)))))
(define k-comb-type
  (pi-ty (a type-type) (type-fun a (pi-ty (b type-type) (type-fun b a)))))

(type?    '() k-comb-type)
(hasType? '() k-comb k-comb-type)

(displayln "checking rejection of bad signatures")
(hasType? '() k-comb id-forall-type)
(hasType? '() id-forall id-unit-type)

(define (new-form type-judgment hasType-judgment eqType-judgment eqVal-judgment)
  (cond [type-judgment    (set! type-judgments    (cons type-judgment    type-judgments))])
  (cond [hasType-judgment (set! hasType-judgments (cons hasType-judgment hasType-judgments))])
  (cond [eqType-judgment  (set! eqType-judgments  (cons eqType-judgment  eqType-judgments))])
  (cond [eqVal-judgment   (set! eqVal-judgments   (cons eqVal-judgment   eqVal-judgments))])
  )

; adding bool
(define type-bool 'type-bool)
(new-form 
 (lambda (cxt t) (eq? t 'type-bool))
 (lambda (cxt x t) (and (eq? t 'type-bool) (boolean? x)))
 #f
 (lambda (cxt t x y) (and (eq? t 'type-bool) (eq? x y))))

(define bool-elim
  (pi (a type-type) (lam (x a) (lam (y a) (lam (b type-bool) (close a (lambda (cxt) (if (red-eval cxt b) x y))))))))

(define bool-induct
  (pi (p (type-fun type-bool type-type))
  (lam (x (app p #t))
  (lam (y (app p #f))
  (pi (bl type-bool)
  (close (app p bl) (lambda (cxt) (if (red-eval cxt bl) x y))))))))

(displayln "functions on bool")
(define not-bool (apps bool-elim type-bool #f #t))
(red-eval '() (app not-bool #t))
(red-eval '() (app not-bool #f))

; adding equality types
(struct type-eq (type v1 v2) #:transparent)
(struct val-eq (v1 v2))

(new-form
 (match-lambda**
  [(cxt (type-eq type v1 v2))
   (and (hasType? cxt v1 type)
        (hasType? cxt v2 type))]
  [(_ _) #f])
 (match-lambda**
  [(cxt 'refl (type-eq type v1 v2)) ;note we ignore the refl
   (eqVal? cxt type v1 v2)]
  [(_ _ _) #f])
 (match-lambda**
  [(cxt (type-eq t1t t1a t1b) (type-eq t2t t2a t2b))
   (and (eqType? cxt t1t t2t) (eqVal? cxt t1t t1a t2a) (eqVal? cxt t1t t1b t2b))]
  [(_ _ _) #f])
 (match-lambda**
  [(cxt (type-eq t a b) _ _) #t]
  [(_ _ _ _) #f])
 )

;intro
(define refl (pi (a type-type) (pi (x a) (close (type-eq a x x) (lambda (cxt) 'refl)))))

(define equal-induct
  (pi (a type-type)
  (pi (c (pi-ty (x a) (pi-ty (y a) (type-fun (type-eq a x y) type-type))))
  (lam (f (pi-ty (z a) (apps c z z 'refl)))
  (pi (m a)
  (pi (n a)
  (pi (p (type-eq a m n))
  (close (apps c m n p) (lambda (cxt) (untyped-app cxt f m))))))))))

(define (untyped-app cxt f x)
  (match (red-eval cxt f)
    [(lam-pi v vt b) (b x)]
    [g (app g x)]))

;  (trustme (apps c m n p) (red-eval '() (app (red-eval '() f) m)))))))))) ;(lambda (cxt) (app (red-eval cxt f) m))))))))))

;todo prove transitivity

(displayln "proving that for all bool, not (not x) = x")

(define not-not-bool (lam (x type-bool) (app not-bool (app not-bool x))))
(define id-bool (lam (x type-bool) x))

; not-not-is-id
(define nnii-fam (lam (x type-bool) (type-eq type-bool (app id-bool x) (app not-not-bool x))))
(hasType? '() nnii-fam (type-fun type-bool type-type))
(hasType? '() 'refl (app nnii-fam #t))

(define nnii-type (pi-ty (x type-bool) (app nnii-fam x)))
(define nnii (pi (x type-bool) (apps bool-induct nnii-fam (apps refl type-bool #t) (apps refl type-bool #f) x)))
(type? '() nnii-type)
(hasType? '() nnii nnii-type)

(displayln "but we don't have extensional function equality")
(define nnii-extensional (type-eq (type-fun type-bool type-bool) id-bool not-not-bool))
(type? '() nnii-extensional)
(hasType? '() 'refl nnii-extensional) ; we shouldn't even be able to write that refl

(displayln "although we do have intensional equality")
(hasType? '() (apps refl (type-fun type-bool type-bool) not-not-bool) (type-eq (type-fun type-bool type-bool) not-not-bool not-not-bool))

(displayln "and we can add eta as an axiom")
(define eta-eq
  (pi (a type-type)
  (pi (b type-type)
  (pi (f (type-fun a b))
  (pi (g (type-fun a b))
  (pi (prf (pi-ty (x a) (type-eq a (app f x) (app g x))))
  (trustme (type-eq (type-fun a b) f g) 'refl)))))))

(define nnii-extensional-term (apps eta-eq type-bool type-bool id-bool not-not-bool nnii))
(hasType? '() nnii-extensional-term nnii-extensional)
(hasType? '() (red-eval '() nnii-extensional-term) nnii-extensional)
(red-eval '() nnii-extensional-term)

(displayln "naturals are easy")
(define type-nat 'type-nat)
(new-form 
 (lambda (cxt t) (eq? t 'type-nat))
 (lambda (cxt x t) (and (eq? t 'type-nat) (exact-integer? x) (>= x 0)))
 #f
 (lambda (cxt t x y) (and (eq? t 'type-nat) (eq? x y))))

(define z 0)
(define succ (lam (x type-nat)
             (close type-nat (lambda (cxt)
               (let ([x1 (red-eval cxt x)])
                 (if (number? x1)
                     (+ x1 1)
                     (trustme type-nat (cons 'succ x1))))))))

(define nat-induct
  (pi (c (type-fun type-nat type-type))
  (lam (base (app c z))
  (lam (induct (pi-ty (n2 type-nat)
                      (type-fun (app c n2) (app c (app succ n2)))))
  (pi (n1 type-nat)
  (close (app c n1) (lambda (cxt) (for/fold ([acc base])
                                           ([x (in-range (red-eval cxt n1))])
                                   (apps induct x acc)))))))))

(define double (apps nat-induct (lam (x type-nat) type-nat) z (pi (x type-nat) (lam (n type-nat) (app succ (app succ n))))))
(red-eval '() (app double (app double (app succ z))))

(define plus (lam (a type-nat)
             (apps nat-induct (lam (x type-nat) type-nat) a (pi (n type-nat) (lam (n type-nat) (app succ n))))))

(red-eval '() (apps plus 5 5))

(displayln "we can use sigma types, for existential proofs")
(struct type-sig (a b) #:transparent)
(define-syntax-rule (sig-ty (x t) body) (type-sig t (lambda (x) body)))
(new-form 
 (match-lambda**
  [(cxt (type-sig a b))
   (and (type? cxt a)
        (extend-cxt 'fst a cxt (newv newcxt)
                    (type? newcxt (b newv))))]
  [(_ _) #f])
 (match-lambda**
  [(cxt (cons x y) (type-sig a b))
      (and (hasType? cxt x a)
           (hasType? cxt y (b x)))]
  [(_ _ _) #f])
 (match-lambda**
  [(cxt (type-sig a b) (type-sig a1 b1))
   (and (eqType? cxt a a1)
        (extend-cxt 'fst a cxt (newv newcxt)
                    (eqType? newcxt (b newv) (b1 newv))))]
  [(_ _ _) #f])
 (match-lambda** 
  [(cxt (type-sig a b) (cons x y) (cons x1 y1))
   (and (eqVal? cxt a x x1)
        (eqVal? cxt (b x) y y1))]
  [(_ _ _ _) #f]))

; every number has a successor
(define has-succ (pi (n type-nat) (cons (app succ n) (apps refl type-nat (app succ n)))))
(define has-succ-type (pi-ty (n type-nat) (sig-ty (x type-nat) (type-eq type-nat x (app succ n)))))
(hasType? '() has-succ has-succ-type)

; every inhabitant of unit is equal to '()
(define unit-induct
  (pi  (c (type-fun type-unit type-type))
  (lam (v (app c '()))
  (pi  (u type-unit)
  (close (app c u) (lambda (env) v))))))
(define is-unit (pi (u type-unit) (cons u (apps unit-induct
                                                (lam (x type-unit) (type-eq type-unit x '()))
                                                (apps refl type-unit '())
                                                u))))
(define is-unit-type (pi-ty (u type-unit) (sig-ty (x type-unit) (type-eq type-unit x '()))))
(hasType? '() is-unit is-unit-type)

(displayln "we have partial type inference")
(define (inferType cxt x1)
  (match (reduce cxt x1)
    [(closure typ b) typ]
    [(trustme typ b) typ]
    [(? symbol? x) #:when (find-cxt x cxt) (find-cxt x cxt)]
    [(lam-pi vn vt body) 
     (extend-cxt vn vt cxt (newvar newcxt)
                 (type-pi newvar vt (lambda (y) (subst y newvar (reduce newcxt (inferType newcxt (body newvar)))))))]
    ['() type-unit]
    [(? number? x) type-nat]
    [(? boolean? x) type-bool]
    [(cons a b) (type-sig (inferType cxt a) (lambda (arg) (inferType cxt b)))] ; can't infer sigmas in general
  ; ['refl ...] -- given a plain refl whats its type?
    ; in both cases, more data in terms can help clean this up...
    [(? (lambda (x) (type? cxt x))) type-type]
    ))

(define/match (subst y v x)
  [(_ _ (? symbol? x)) #:when (eq? x y) y]
  [(_ _ (closure typ b)) (closure (abs y v typ) (lambda (cxt) (subst y v (b cxt))))]
  [(_ _ (trustme typ b)) (closure (subst y v typ) (subst y v b))]
  [(_ _ (lam-pi vn vt body)) (lam-pi vn (subst y v vt) (lambda (arg) (subst y v (body arg))))]
  [(_ _ (cons a b))       (cons     (subst y v a) (subst y v b))]
  [(_ _ (type-fun  a b))  (type-fun (subst y v a) (subst y v b))]
  [(_ _ (type-eq t a b))  (type-eq  (subst y v t) (subst y v a) (subst y v b))]
  [(_ _ (type-pi av a b)) (type-pi av (subst y v a) (lambda (arg) (subst y v (b arg))))]
  [(_ _ (type-sig   a b)) (type-sig (subst y v a) (lambda (arg) (subst y v (b arg))))]
  [(_ _ _) x]
  )

(define (saturate cxt x)
  (match (reduce cxt x) 
    [(closure typ b) (closure (saturate cxt typ) (saturate cxt (red-eval cxt (b cxt))))]
    [(trustme typ b) (trustme (saturate cxt typ) b)]
    [(lam-pi vn vt body)
     (extend-cxt vn vt cxt (newvar newcxt)
                 (lam-pi vn vt (saturate newcxt (body newvar))))]
    [(cons a b)       (cons     (saturate cxt a) (saturate cxt b))]
    [(type-fun   a b) (type-fun (saturate cxt a) (saturate cxt b))]
    [(type-eq  t a b) (type-eq  (saturate cxt t) (saturate cxt a) (saturate cxt b))]
    [(type-pi av a b) 
     (extend-cxt av a cxt (newvar newcxt)
                 (type-pi newvar (saturate newcxt a) (saturate newcxt (b newvar))))]
    [(type-sig a b)
     (extend-cxt 'fst a cxt (newvar newcxt)
                 (type-sig (saturate newcxt a) (saturate newcxt (b newvar))))]
    [v v]
    ))

(saturate '() (inferType '() id-bool))
(saturate '() (inferType '() not-not-bool))
(saturate '() (inferType '() nnii))
(saturate '() (inferType '() (cons #t '())))

(displayln "we can build either from sigma")
(define (either-type a b) (sig-ty (bl type-bool)
                                  (apps bool-elim type-type a b bl)))
(define left  (pi (t type-type) (lam (a t) (cons #t a))))
(define right (pi (t type-type) (lam (a t) (cons #f a))))

(hasType? '() (apps left type-nat 5) (either-type type-nat type-nat))

(define maybe-zero (pi (n type-nat) (either-type (type-eq type-nat n z) type-bool)))
(define zero-or-not (apps nat-induct 
                              (lam (x type-nat) (app maybe-zero x))
                              (apps left (type-eq type-nat z z) (apps refl type-nat z))
                              (pi (x type-nat) (lam (y (app maybe-zero x)) (apps right type-bool #f)))))

(hasType? '() (pi (x type-nat) (app zero-or-not x)) (pi-ty (x type-nat) (app maybe-zero x)))

(displayln "we can introduce a type for falsehood, and use it to show contradiction.")
(define type-false 'false)
(new-form 
 (lambda (cxt t) (eq? t 'false))
 #f
 #f
 (lambda (cxt t x y) (eq? t 'false)))

(define transport
  (pi (a type-type)
  (pi (p (type-fun a type-type))
  (apps equal-induct
        a
        (pi (x a) (pi (y a) (lam (q (type-eq a x y)) (type-fun (app p x) (app p y)))))
        (pi (z a) (lam (v (app p z)) v))))))

(define trivial-transport (apps transport type-bool (lam (x type-bool) type-nat) #t #t (apps refl type-bool #t)))
(red-eval '() (app trivial-transport 4))

(define true-is-false (type-eq type-bool #t #f))
(define bool-to-type (apps bool-elim type-type type-unit type-false))

(define contradiction-implies-false
  (lam (absurd true-is-false)
  (apps transport type-bool bool-to-type #t #f absurd '())))

(hasType? '() contradiction-implies-false (type-fun true-is-false type-false))
(hasType? '() (app contradiction-implies-false (trustme true-is-false 'haha)) type-false)
(red-eval '() (app contradiction-implies-false (trustme true-is-false 'haha)))



;(define equal-induct
;  (pi (a type-type)
;  (pi (c (pi-ty (x a) (pi-ty (y a) (type-fun (type-eq a x y) type-type))))
;  (lam (f (pi-ty (z a) (apps (c z z 'refl))))
;  (pi (m a)
;  (pi (n a)
;  (pi (p (type-eq m n))
;  (close (apps c m n p) (lambda (cxt) (app (red-eval cxt f) m))))))))))


;(define bool-induct
;  (pi (p (type-fun type-bool type-type))
;  (lam (x (app p #t))
;  (lam (y (app p #f))
;  (pi (bl type-bool)
;  (close (app p bl) (lambda (cxt) (if (red-eval cxt bl) x y))))))))


(define/match (check-universes cxt x)
  [(_ (lam-pi vn vt body))
   (let/match ([(cons vu vcxt) (check-universes cxt vt)])
              (extend-cxt vn vu vcxt (nvar newcxt)
                          (check-universes newcxt (body nvar))))]
                            )] ; if the type is u0 then the body must be u1 iff its type varies based on the type. -- we need to distingush lam, pi
  [(_ (cons a b)) '()]; ditto -- if we have dependency then one thing else another.. sigh.
  )


(define-syntax-rule (extend-cxt var vt cxt (newvar newcxt) body)
  (let* ([newvar (fresh-var var cxt)]
         [newcxt (cons (cons newvar vt) cxt)])
    body))

   
   
; todo universes?
;  (match (reduce cxt x) 
;    [(closure typ b) (closure (saturate cxt typ) (saturate cxt (red-eval cxt (b cxt))))]
;    [(trustme typ b) (trustme (saturate cxt typ) b)]
;    [(lam-pi vn vt body)
;     (extend-cxt vn vt cxt (newvar newcxt)
;                 (lam-pi vn vt (saturate newcxt (body newvar))))]
;    [(cons a b)       (cons     (saturate cxt a) (saturate cxt b))]
;    [(type-fun   a b) (type-fun (saturate cxt a) (saturate cxt b))]
;    [(type-eq  t a b) (type-eq  (saturate cxt t) (saturate cxt a) (saturate cxt b))]
;    [(type-pi av a b) 
;     (extend-cxt av a cxt (newvar newcxt)
;                 (type-pi newvar (saturate newcxt a) (saturate newcxt (b newvar))))]
;    [(type-sig a b)
;     (extend-cxt 'fst a cxt (newvar newcxt)
;                 (type-sig (saturate newcxt a) (saturate newcxt (b newvar))))]
;    [v v]
;    ))

; heterogeneous equality?
; todo looping y combinator?
; todo cubes?
; todo tactics? term is (partial term, full desired type)

; references
; Simply Easy: http://strictlypositive.org/Easy.pdf
; Simpler, Easier: http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
; PTS: http://hub.darcs.net/dolio/pts
; Pi-Forall: https://github.com/sweirich/pi-forall

